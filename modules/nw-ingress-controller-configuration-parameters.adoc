// Module included in the following assemblies:
//
// * networking/ingress-operator.adoc

:_mod-docs-content-type: REFERENCE
[id="nw-ingress-controller-configuration-parameters_{context}"]
= Ingress Controller configuration parameters

The `ingresscontrollers.operator.openshift.io` resource includes
configuration parameters that you can use in either cloud and non-cloud environments. Each parameter is optional for your {product-title} cluster configuration.

//domain parameter
::`domain`::

Specifies a Domain Name System (DNS) name that is serviced by the Ingress Controller. If not set, defaults to using the value defined in the `ingress.config.openshift.io/cluster.spec.domain` object. You can use this parameter to configure the following features for your cluster:

* For the `LoadBalancerService` endpoint publishing strategy, `domain` is used to configure DNS records. See `endpointPublishingStrategy`.
* When using a generated default certificate, the certificate is valid for `domain` and its `subdomains`. See `defaultCertificate`.
* The value is published to individual Route statuses so that users know where to target external DNS records.

The `domain` value must be unique among all Ingress Controllers and cannot be updated.

//replicas parameter
::`replicas`::

Specifies the preferred number of Ingress Controller replica for your cluster. If not set, the default value is `2`.

// endpointPublishingStrategy parameter (cloud environments)
::`endpointPublishingStrategy`::

Publishes the `LoadBlancerService`, HostNetwork`, or `NodePortService` Ingress Controller endpoint to other networks, enables load balancer integrations, and provides access to other systems.

The `HostNetwork` `NodePortService` endpoints operate in non-cloud environments. For more information, see "Ingress Controller endpoint publishing strategy" in _Configuring the Ingress Controller endpoint publishing strategy_.

ifndef::openshift-rosa,openshift-dedicated[]
On GCP, AWS, and Azure you can configure the following `endpointPublishingStrategy` fields:
endif::openshift-rosa,openshift-dedicated[]
ifdef::openshift-rosa,openshift-dedicated[]
You can configure the following `endpointPublishingStrategy` fields:
endif::openshift-rosa,openshift-dedicated[]

* `loadBalancer.scope`
* `loadBalancer.allowedSourceRanges`
ifndef::openshift-rosa[]
* `loadbalancer.providerParameters.gcp.clientAccess` (GCP only)
endif::openshift-rosa[]

[NOTE]
====
On {rh-openstack-first}, the `LoadBalancerService` endpoint publishing strategy is only supported if a cloud provider is configured to create health monitors. For {rh-openstack} 16.2, this strategy is only possible if you use the Amphora Octavia provider.

For more information, see the "Setting cloud provider options" section of the {rh-openstack} installation documentation.
====

If you do not specify a value for the parameter, one of the following platoform-dependent default values are taken from `infrastructure.config.openshift.io/cluster.status.platform` object:

ifdef::openshift-rosa,openshift-dedicated[]
* Amazon Web Services (AWS): `LoadBalancerService` (with External scope)
endif::openshift-rosa,openshift-dedicated[]
ifdef::openshift-dedicated[]
* Google Cloud Platform (GCP): `Load BalancerService` (with External scope)
endif::openshift-dedicated[]
ifndef::openshift-rosa,openshift-dedicated[]
* Azure: `LoadBalancerService` (with External scope)
* Google Cloud Platform (GCP): `LoadBalancerService` (with External scope)
endif::openshift-rosa,openshift-dedicated[]

// defaultCertificate parameter
::`defaultCertificate`::

References the secret that contains the default certificate that is served by the Ingress Controller.

The secret must contain the following keys and data:
* `tls.crt`: certificate file contents
* `tls.key`: key file contents

If Routes does not specify their own certificates, the `defaultCertificate` is used. If you do not set the parameter, a wildcard certificate is automatically generated and used. The certificate is valid for the Ingress Controller `domain` and `subdomains`. Additionally, the generated certificate's CA is automatically integrated with the cluster's truststore.

The in-use certificate, either generated or user-specified, is automatically integrated with {product-title} built-in OAuth server.

// namespaceSelector
::`namespaceSelector`::
Filters the set of namespaces serviced by the
Ingress Controller. The parameter is useful for implementing shards.

// routeSelector
::`routeSelector`::
Filters the set of Routes serviced by the Ingress Controller. This is useful for implementing shards.

// nodePlacement
::`nodePlacement`::
Enables explicit control over the scheduling of the Ingress Controller. If not set, the defaults values are used.

The `nodePlacement` parameter includes two parts, `nodeSelector` and `tolerations`, which are shows in the following example:

[source,yaml]
----
# ...
nodePlacement:
 nodeSelector:
   matchLabels:
     kubernetes.io/os: linux
 tolerations:
 - effect: NoSchedule
   operator: Exists
# ...
----


// tlsSecurityProfile
::`tlsSecurityProfile`::

Specifies settings for TLS connections for Ingress Controllers. If not set, defaults to using a value from the `apiservers.config.openshift.io/cluster` resource.

When using the `Old`, `Intermediate`, and `Modern` profile types, the effective profile configuration is subject to change between releases. For example, given a specification to use the `Intermediate` profile deployed on release `X.Y.Z`, an upgrade to release `X.Y.Z+1` may cause a new profile configuration to be applied to the Ingress Controller, resulting in a rollout.

The minimum TLS version for Ingress Controllers is `1.1`, and the maximum TLS version is `1.3`. Ciphers and the minimum TLS version of the configured security profile are reflected in the `TLSProfile` status.

[IMPORTANT]
====
The Ingress Operator converts the TLS `1.0` of an `Old` or `Custom` profile to `1.1`.
====

// clientTLS
::`clientTLS`::

Authenticates client access to the cluster and services so that mutual TLS authentication is enabled for your cluster. If not set, the client TLS is not enabled. The parameter includes the `spec.clientTLS.clientCertificatePolicy` and `spec.clientTLS.ClientCA` subfields.

The `ClientCertificatePolicy` subfield accepts one of the two values: `Required` or `Optional`. The `ClientCA` subfield specifies a config map that is in the `openshift-config` namespace. The config map should contain a CA certificate bundle.

The `AllowedSubjectPatterns` is an optional value that specifies a list of regular expressions, which are matched against the distinguished name on a valid client certificate to filter requests. The regular expressions must use Perl Compatible Regular Expressions (PCRE) syntax. At least one pattern must match a client certificate's distinguished name; otherwise, the Ingress Controller rejects the certificate and denies the connection. If not specified, the Ingress Controller does not reject certificates based on the distinguished name.

// routeAdmission
::`routeAdmission`::

Defines a policy for handling new route claims, such as allowing or denying claims across namespaces.

The `namespaceOwnership` field describes how hostname claims across namespaces should be handled. This field supports the following values:

* `Strict`: The default value. This value does not allow routes to claim the same hostname across namespaces.
* `InterNamespaceAllowed`: allows routes to claim different paths of the same hostname across namespaces.

The `wildcardPolicy` field describes how routes with wildcard policies are handled by the Ingress Controller. This field supports the following values:

* `WildcardsAllowed`: Indicates routes with any wildcard policy are admitted by the Ingress Controller.
* `WildcardsDisallowed`: Indicates only routes with a wildcard policy of `None` are admitted by the Ingress Controller. Updating `wildcardPolicy` from `WildcardsAllowed` to `WildcardsDisallowed` causes admitted routes with a wildcard policy of `Subdomain` to stop working. These routes must be recreated to a wildcard policy of `None` to be readmitted by the Ingress Controller. `WildcardsDisallowed` is the default setting.

// IngressControllerLogging
::`IngressControllerLogging`::

The `IngressControllerLogging` supports many parameters. The following examples shows some of these parameters. For more information about supported parameters, see "Configuring Ingress access logging".

[source,yaml]
----
apiVersion: operator.openshift.io/v1
kind: IngressController
metadata:
  name: default
  namespace: openshift-ingress-operator
spec:
  replicas: 2
  logging: <1>
    access: <2>
      destination: <3>
        type: Container <4>
# ...
----
<1> Defines data for what is logged and its location. If you do not specify a value, operational logs are enabled but access logs are disabled.
<2> Describes the mechanism for logging client requests. If you do not specify a value, access logging is disabled.
<3> Describes a destination for log messages.
<4> Defines the type of destination for logs. Supported value include `Container` or `Syslog`.

// httpHeaders.forwardedHeaderPolicy
::`httpHeaders.forwardedHeaderPolicy`::
The `httpHeaders` parameter defines the policy for HTTP headers.

By setting the `httpHeaders.forwardedHeaderPolicy` for the `IngressControllerHTTPHeaders` implementation, you specify when and how the Ingress Controller sets the `Forwarded`, `X-Forwarded-For`, `X-Forwarded-Host`, `X-Forwarded-Port`, `X-Forwarded-Proto`, and `X-Forwarded-Proto-Version` HTTP headers.

By default, the policy is set to `Append`.

* `Append` specifies that the Ingress Controller appends the headers, preserving any existing headers.
* `Replace` specifies that the Ingress Controller sets the headers, removing any existing headers.
* `IfNone` specifies that the Ingress Controller sets the headers if they are not already set.
* `Never` specifies that the Ingress Controller never sets the headers, preserving any existing headers.

// httpHeaders.headerNameCaseAdjustments
::`httpHeaders.headerNameCaseAdjustments`::

By setting `httpHeaders.headerNameCaseAdjustments`, you can specify case adjustments that get applied to HTTP header names. Each adjustment is specified as an HTTP header name with your chosen capitalization. For example, specifying `X-Forwarded-For` indicates that the `x-forwarded-for` HTTP header is adjusted to have the specified capitalization. These adjustments are only applied to plain text, edge-terminated, and re-encrypt routes, and only when using HTTP/1.

For request headers, these adjustments are applied only for routes that have the `haproxy.router.openshift.io/h1-adjust-case=true` annotation. For response headers, these adjustments are applied to all HTTP responses. If this field is empty, no request headers are adjusted.

// httpHeaders.actions
::`httpHeaders.actions`::

Specifies options for performing certain actions on headers. You cannot set or delete headers for TLS passthrough connections. The `actions` parameter supports the following subfields `spec.httpHeader.actions.response` and `spec.httpHeader.actions.request`. The `response` subfield specifies a list of HTTP response headers to set or delete. The `request` subfield specifies a list of HTTP request headers to set or delete.

// httpCompression
::`httpCompression`::

Defines the policy for HTTP traffic compression. Supports the `mimeTypes` sub-parameter. For more information, see "Using router compression".

// I do not understand why the Content-Type was listed here as it belongs o the `httpCaptureHeaders` implementation? See the description for the httpCaptureHeaders parameter.
////
The `types` are: application, image, message, multipart, text, video, or a custom type prefaced by `X-`; e.g. To see the full notation for MIME types and subtypes, see link:https://datatracker.ietf.org/doc/html/rfc1341#page-7[RFC1341]
////

// httpErrorCodePages
::`httpErrorCodePages`::

Specifies custom HTTP error code response pages. By default, an Ingress Controller uses error pages built into the Ingress Controller's image.

// httpCaptureCookies
::`httpCaptureCookies`::

Specifies HTTP cookies that you want to capture in access logs. If you do not specify a value, the access logs do not capture the cookies.

For any cookie that you want to capture, the following parameters must be in your `IngressController` configuration:

* `name`: Specifies the name of the cookie.
* `maxLength`: Specifies the maximum length of the cookie.
* `matchType`: Specifies if the field `name` of the cookie exactly matches the capture cookie setting or is a prefix of the capture cookie setting. The `matchType` field uses the `Exact` and `Prefix` parameters.

For example:
[source,yaml]
----
# ...
  httpCaptureCookies:
  - matchType: Exact
    maxLength: 128
    name: MYCOOKIE
# ...
----

// httpCaptureHeaders
::`httpCaptureHeaders`::

Specifies the HTTP headers that you want to capture in the access logs. If you do not specify a value, the access logs do not capture the headers. The parameter contains two lists of headers to capture in the access logs. The two lists of header fields are `request` and `response`. In both lists, the `name` field must specify the header name and the `maxlength` field must specify the maximum length of the header. For example:

[source,yaml]
----
# ...
  httpCaptureHeaders:
    request:
    - maxLength: 256
      name: Connection
    - maxLength: 128
      name: User-Agent
    response:
    - maxLength: 256
      name: Content-Type
    - maxLength: 256
      name: Content-Length
# ...
----

// tuningOptions
::`tuningOptions`::

Specifies options for tuning the performance of Ingress Controller pods. The parameters supports the following sub-parameters:

* `clientFinTimeout`: Specifies how long a connection remains open until the client response to the server closes the connection. The default timeout is `1s`.
* `clientTimeout`: Specifies how long a connection stays open until it receives a client response. The default timeout is `30s`.
* `headerBufferBytes`: Specifies how much memory is reserved, in bytes, for Ingress Controller connection sessions. If HTTP/2 is enabled for the Ingress Controller, the value must be at least `16384`. If you do not set a value, the default value is `32768` bytes. Too small a value can break the Ingress Controller while too large a value could cause the Ingress Controller to use significantly more memory than necessary.
* `headerBufferMaxRewriteBytes`: Specifies how much memory should be reserved, in bytes, from `headerBufferBytes` for HTTP header rewriting and appending for Ingress Controller connection sessions. The minimum value for `headerBufferMaxRewriteBytes` is `4096`. Ensure that `headerBufferBytes` is greater than `headerBufferMaxRewriteBytes` for incoming HTTP requests. If you do not set a value, the default value is `8192` bytes. Too small a value can break the Ingress Controller while too large a value could cause the Ingress Controller to use significantly more memory than necessary.
* `healthCheckInterval`: Specifies how long the router waits between health checks. The default value is `5s`.
* `serverFinTimeout`: Specifies how long a connection remains open until the server response to the client that closes the connection. The default timeout is `1s`.
* `serverTimeout`: Specifies how long a connection remains open while waiting for a server response. The default timeout is `30s`.
* `threadCount`: Specifies the number of threads to create for each HAProxy process. Creating more threads allows each Ingress Controller pod to handle more connections. HAProxy supports up to `64` threads. If you do not set a value, the Ingress Controller uses the default value of `4` threads. Increasing the number of HAProxy threads allows Ingress Controller pods to use more CPU time under load and prevents other pods from receiving the CPU resources they need to perform tasks. Reducing the number of threads can cause the Ingress Controller to under perform.
* `tlsInspectDelay`:  Specifies how long the router can hold data to find a matching route. Setting this value too short can cause the router to fall back to the default certificate for edge-terminated, reencrypted, or passthrough routes, even when using a better matched certificate. The default inspect delay is `5s`.
* `tunnelTimeout`: Specifies how long a tunnel connection, including websockets, remains open while the tunnel is idle. The default timeout is `1h`.
* `maxConnections`: Specifies the maximum number of simultaneous connections that can be established for each HAProxy process. Increasing this value allows each Ingress Controller pod to handle more connections at the cost of additional system resources. The parameter supports the following values:
** Empty or the value of `0` means that the Ingress Controller uses the default value of `50000`.
** A value of `-1` means that the HAProxy dynamically computes a maximum value based on the available `ulimits` in the running container. This process results in a large computed value that incurs significant memory usage compared to the current default value of `50000`. If you have nodes configured with different `ulimits` and you want to set a discrete value for the sub-parameter, use the value of `-1` so that the maximum number of connections gets calculated at runtime.
+
[NOTE]
====
Setting a discrete value when a router pod is migrated to a new node could cause the pod failure because the new node might have a different `ulimit` value.
====
** Any value within the range `2000` and `2000000`. If the field has a value that is greater than the current operating system limit, the HAProxy process will not start.

//CONTINUE FROM HERE. REVISIT TO MOVE PARAMTERS TO YAML EXAMPLES IN OTHER SECTIONS IN THE SAME DOC BOOK
// logEmptyRequests
::`logEmptyRequests`::
`logEmptyRequests` specifies connections for which no request is received and logged. These empty requests come from load balancer health probes or web browser speculative connections (preconnect) and logging these requests can be undesirable. However, these requests can be caused by network errors, in which case logging empty requests can be useful for diagnosing the errors. These requests can be caused by port scans, and logging empty requests can aid in detecting intrusion attempts. Allowed values for this field are `Log` and `Ignore`. The default value is `Log`.

The `LoggingPolicy` type accepts either one of two values:

* `Log`: Setting this value to `Log` indicates that an event should be logged.
* `Ignore`: Setting this value to `Ignore` sets the `dontlognull` option in the HAproxy configuration.

// HTTPEmptyRequestsPolicy
::`HTTPEmptyRequestsPolicy`::
`HTTPEmptyRequestsPolicy` describes how HTTP connections are handled if the connection times out before a request is received. Allowed values for this field are `Respond` and `Ignore`. The default value is `Respond`.

The `HTTPEmptyRequestsPolicy` type accepts either one of two values:

* `Respond`: If the field is set to `Respond`, the Ingress Controller sends an HTTP `400` or `408` response, logs the connection if access logging is enabled, and counts the connection in the appropriate metrics.
* `Ignore`: Setting this option to `Ignore` adds the `http-ignore-probes` parameter in the HAproxy configuration. If the field is set to `Ignore`, the Ingress Controller closes the connection without sending a response, then logs the connection, or incrementing metrics.

These connections come from load balancer health probes or web browser speculative connections (preconnect) and can be safely ignored. However, these requests can be caused by network errors, so setting this field to `Ignore` can impede detection and diagnosis of problems. These requests can be caused by port scans, in which case logging empty requests can aid in detecting intrusion attempts.
